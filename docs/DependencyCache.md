Okay, here is the updated documentation reflecting the full implementation provided.

---

## Dependency Cache Visualizer - Documentation

**Version:** 1.3.0 *(Reflecting Full Basic Implementation)*
**Approach:** Standalone Server (FastAPI + Uvicorn) with Instance Injection, React Frontend (Vite)

### 1. Overview

The Dependency Cache Visualizer is a development tool designed to help developers understand, debug, and interact with applications using the `DataCache` (built upon `DependencyTree`). It's particularly useful when cache paths follow **structured, deterministic conventions**, often generated by helper functions (like those provided in `dependency_cache_visualizer.path_utils`).

Its primary goal is to provide **observability** into your application's caching behavior during development. Run the visualizer alongside your application and watch how the cache structure and statistics change as your application runs.

**Core Features (Implemented):**

*   **Cache Tree Visualization:** Displays the hierarchical structure of your dependency cache.
*   **Manual & Auto-Refreshing:** Fetch updated cache state manually or via periodic polling.
*   **Basic Node Inspection:** Click nodes to see their full path, metadata (timestamp, hash), and a simple data preview (JSON stringified) in a details panel.
*   **Interactive Operations:** Add, retrieve, and invalidate cache nodes directly through the web interface using slash-separated paths.
*   **Performance Statistics:** Monitor cache performance (hits, misses, adds, invalidations) globally and view counts per path. Reset statistics via the UI.
*   **Click-to-Populate Path:** Clicking a node in the tree fills the "Path" input for operations.

**Planned / Future Enhancements:**

*   *Visual Change Highlighting:* Automatically highlighting new, updated, or invalidated nodes on refresh.
*   *Context Menu:* Right-click actions on nodes (Copy Path, Get, Invalidate).
*   *Operations Log:* History of UI-initiated operations.
*   *Toast Notifications:* Feedback for UI operations.
*   *Enhanced Data Previews:* Better handling for complex types like DataFrames.
*   *Tree Search/Filtering:* For navigating large trees.

This tool runs as a **separate, lightweight web server process** (FastAPI + Uvicorn) during development. You inject your application's *live* `DataCache` instance into the visualizer when starting it. The frontend is a React single-page application built with Vite.

**Key Benefit:** Provides direct insight into your application's caching behavior *without* modifying your core application logic significantly. **This tool is intended for development environments only.**

### 2. Architecture

```mermaid
graph TD
    subgraph Your Application Process
        A[Your Application Code] --> B(Create DataCache Instance);
        A -- Uses --> PU[Path Utils];
        PU -- Generates --> PathList[List[str]];
        A -- Uses Path --> B;
        B -- 1. Instance --> C{Call start_visualizer(cache_instance)};
    end

    subgraph Visualizer Server Process (Started by C)
        D[FastAPI Server (Uvicorn)] -- Holds Reference via app_state --> B;
        D -- Serves Static Files --> E[React Frontend Build (in frontend_build/)]
        D -- API Endpoints (/api/*) --> F((API Logic - routes.py));
        F -- 2. Interact --> B;
    end

    subgraph Developer's Browser
        G[Browser] -- Loads --> E;
        G -- 3. API Calls (/api/*) --> D;
        G -- Displays --> H{Cache Tree, Stats, Details};
        G -- User Actions --> I[Operation Forms];
        I -- Triggers --> G;
    end

    subgraph Frontend Development (Optional)
        J[Vite Dev Server] -- Serves --> G;
        J -- Proxies /api/* --> D;
    end

    style B fill:#f9f,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px
    style E fill:#9cf,stroke:#333,stroke-width:2px
    style PU fill:#f0ad4e, stroke:#333, stroke-width:1px
    style J fill:#lightgrey, stroke:#333, stroke-width:1px
```

**Explanation:**

1.  Your application creates a `DataCache` instance.
2.  Your application uses `path_utils` (or similar logic) to generate structured `List[str]` paths for cache operations.
3.  Your development startup script calls `start_visualizer`, passing the live `DataCache` instance.
4.  `start_visualizer` stores the instance reference and starts the FastAPI/Uvicorn server in a separate task/process.
5.  The FastAPI backend serves the static React frontend assets located in the `src/dependency_cache_visualizer/visualizer/frontend_build/` directory.
6.  The developer accesses the visualizer's URL (e.g., `http://localhost:8001`) in their browser.
7.  The browser loads the React application.
8.  The React frontend makes API calls to the backend's `/api/*` endpoints (e.g., `/api/tree`, `/api/stats`, `/api/add-data`). If auto-refresh is enabled, the frontend periodically polls `/api/tree` and `/api/stats`.
9.  The visualizer backend API handlers (in `routes.py`), using the injected `DataCache` instance, perform the requested actions (get tree structure, get stats, add data, invalidate, etc.).
10. The results are sent back to the frontend, which updates the UI (tree view, stats panel, details panel).
11. **(Frontend Development Only):** When running the Vite dev server (`npm run dev` in `frontend/`), it serves the frontend directly and proxies `/api/*` requests to the running backend server (FastAPI) based on `vite.config.js`.

### 3. User Interface Features (Current Implementation)

*   **Manual Refresh:** Button to fetch the latest tree and stats on demand.
*   **Auto-Refresh Option:**
    *   **UI:** Dropdown to select refresh interval (Manual, 5s, 10s, 30s).
    *   **Mechanism:** Frontend periodically polls `/api/tree` and `/api/stats` using `setInterval`.
*   **Tree View:**
    *   Displays cache nodes hierarchically.
    *   Expand/collapse nodes.
    *   Indicates if a node has data (`font-medium`).
    *   Shows basic indicators (data presence, hash) on hover.
*   **Node Details Panel:**
    *   **UI:** Dedicated panel shows details of the *last clicked* node.
    *   **Content:** Full Path, Identifier, Has Data status, Timestamp, Data Hash.
    *   **Data Preview:** Simple preview using `JSON.stringify`. *Note: Not suitable for large or complex non-JSON serializable objects (e.g., DataFrames).*
*   **Click-to-Populate Path:** Clicking a node in the tree automatically fills the "Path" input field in the "Operations" section.
*   **Operations Panel:**
    *   Input field for slash-separated path.
    *   Text area for data input (treated as JSON if parsable, otherwise string).
    *   Buttons for "Get Data", "Add/Update Data", "Invalidate Path".
    *   Displays success/failure status of the last operation.
*   **Statistics Panel:**
    *   Displays global counts (Gets, Hits, Misses, Adds, Invalidations).
    *   Calculates and displays Hit Ratio.
    *   Shows counts of unique paths involved in different operations (Checked, Hit, Missed, Added, Invalidated).
    *   Button to reset all statistics via `/api/reset-stats`.

### 4. Data Flow Examples

*   **Viewing the Tree:**
    1.  Browser loads React app from Visualizer Backend.
    2.  React app calls `GET /api/tree`.
    3.  Backend calls `serialize_node(cache.dependency_tree.root)`.
    4.  Backend returns JSON tree structure.
    5.  React app renders the `TreeView` component.
*   **Adding Data (via Visualizer):**
    1.  User enters `"users/user123"` in Path input, `{"name": "Alice"}` in Data input, clicks "Add".
    2.  React app calls `POST /api/add-data` with `{"path": ["users", "user123"], "data": {"name": "Alice"}}`.
    3.  Backend calls `await cache.add_or_update_data(["users", "user123"], {"name": "Alice"})`.
    4.  Backend returns `{"message": "Data added/updated successfully"}`.
    5.  React app displays success message and triggers a data refresh (`GET /api/tree`, `GET /api/stats`).
*   **Application Cache Hit & Observation:**
    1.  Your *main application code* generates `my_path = ["raw_data", "nse", "RELIANCE", ...]` using `path_utils` and calls `await data_cache.get_data(my_path)`.
    2.  The `DataCache` instance finds the data, updates its internal hit statistics for the path key (`raw_data/nse/RELIANCE/...`), and returns the data.
    3.  *Later*, when the developer manually refreshes the Visualizer UI *or when the auto-refresh interval triggers*:
        *   Frontend requests `GET /api/tree` and `GET /api/stats`.
        *   Visualizer Backend calls `cache.dependency_tree.root` (and serializes) and `cache.get_stats()`.
        *   The updated data (including increased hit count for the path) is returned.
        *   The Frontend updates the `TreeView` and `StatsPanel` components.

### 5. Path Generation & Structure

*   The visualizer relies on your application using structured, list-based paths, ideally generated by helper functions like those in `dependency_cache_visualizer.path_utils.builders`.
*   The tree view mirrors this path structure.
*   When using the "Operations" panel in the UI, enter the **slash-separated path string** (e.g., `raw_data/yahoo/AAPL/start_2023-01-01/...`). This string is parsed into a `List[str]` before being sent to the backend API.
*   **Tip:** Use the **click-to-populate** feature by clicking a node in the tree to automatically fill the Path input field accurately.

### 6. Installation

```bash
pip install dependency-cache-visualizer
```
*(Requires Python 3.8+. Includes FastAPI, Uvicorn, etc.)*

### 7. Usage

1.  **Instantiate `DataCache`:** Use `dependency_cache_visualizer.core.DataCache` in your application.

    ```python
    from dependency_cache_visualizer.core import DataCache
    my_app_cache = DataCache()
    ```

2.  **Use Path Utils:** Generate cache paths using functions from `dependency_cache_visualizer.path_utils` or similar consistent logic.

    ```python
    from dependency_cache_visualizer.path_utils import build_raw_data_path
    raw_path = build_raw_data_path("yahoo", "MSFT", "2023-01-01", "2023-12-31", "1d")
    # await my_app_cache.add_or_update_data(raw_path, fetched_data)
    ```

3.  **Start Visualizer:** Invoke `start_visualizer` in your development startup code, passing the live cache instance.

    ```python
    # In your run_dev.py or similar (like examples/run_dev_example.py)
    import asyncio
    import logging
    from dependency_cache_visualizer import start_visualizer, DataCache

    # Configure logging if desired
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # Assume my_app_cache is your application's cache instance
    my_app_cache = DataCache()

    async def main_dev():
        # Your application setup...
        # Simulate some cache activity (optional)
        # ...

        log = logging.getLogger(__name__)
        log.info("Starting Dependency Cache Visualizer...")
        visualizer_port = 8001
        # Run the visualizer server as a background task
        visualizer_task = asyncio.create_task(
            start_visualizer(
                cache_instance=my_app_cache,
                host="127.0.0.1",
                port=visualizer_port,
                log_level="info" # Uvicorn log level
            )
        )
        log.info(f"Visualizer UI available at http://127.0.0.1:{visualizer_port}")
        await asyncio.sleep(1) # Give visualizer a moment to start

        # Keep your main application running (e.g., run simulation, start web server)
        print("Main application running (or simulation starting)...")
        # Example: await simulate_data_processing() # From run_dev_example.py
        await asyncio.Event().wait() # Wait indefinitely

    if __name__ == "__main__":
        try:
            asyncio.run(main_dev())
        except KeyboardInterrupt:
            print("\nShutting down.")
    ```

4.  **Access UI:** Run your development script. Navigate to the visualizer URL (e.g., `http://127.0.0.1:8001`) in your browser.
5.  **Interact:** Use the refresh buttons, auto-refresh dropdown, click nodes, and use the operations panel.

### 8. Package Components

*   **`src/dependency_cache_visualizer/`**: Python package source.
    *   **`core/`**: Contains `DependencyNode`, `DependencyTree`, `DataCache` (core async caching logic).
    *   **`path_utils/`**: Helper functions (`builders.py`) for creating structured cache paths.
    *   **`visualizer/`**: Backend API and frontend serving logic.
        *   `__init__.py`: Exports `start_visualizer`.
        *   `app.py`: FastAPI app creation, CORS, static file serving, lifespan management.
        *   `routes.py`: Defines API endpoints (`/api/*`) using FastAPI router.
        *   `schemas.py`: Pydantic models for API request/response validation.
        *   **`frontend_build/`**: **Contains the compiled static assets (HTML, JS, CSS) of the React frontend.** This directory is included in the Python package distribution.
*   **`frontend/`**: React frontend source code (for development).
    *   `package.json`: Frontend dependencies (React, Vite, etc.) and scripts (`dev`, `build`).
    *   `vite.config.js`: Vite build configuration (sets output dir to `../src/.../frontend_build/`, configures dev proxy).
    *   `src/`: React component source files (`App.jsx`, `DependencyCacheVisualizer.jsx`, `TreeView.jsx`, `StatsPanel.jsx`, etc.) and API service (`services/api.js`).
*   **`examples/`**: Example usage scripts (`run_dev_example.py`).
*   **`tests/`**: (Optional) Unit/integration tests.

### 9. Configuration

*   **Backend (`start_visualizer` function):**
    *   `cache_instance`: (Required) The live `DataCache` object.
    *   `host`: (Optional) Host for the backend server (default: `"127.0.0.1"`).
    *   `port`: (Optional) Port for the backend server (default: `8001`).
    *   `log_level`: (Optional) Log level for Uvicorn (default: `"info"`).
    *   `reload`: (Optional) Enable Uvicorn auto-reload (default: `False`, mainly for visualizer *backend* development).
*   **Frontend (Development - `frontend/vite.config.js`):**
    *   `server.port`: Port for the Vite development server (default: `5173`).
    *   `server.proxy`: Configures proxying of `/api` requests to the backend server during development. Ensure the `target` matches your backend address (`http://127.0.0.1:8001`).
    *   `build.outDir`: Specifies the output directory for `npm run build`. **Must point to `src/dependency_cache_visualizer/visualizer/frontend_build/`**.

### 10. Troubleshooting

*   **Visualizer UI Not Loading (404 Error):**
    *   Ensure the backend server (`start_visualizer`) is running without errors.
    *   Verify that the `frontend_build/` directory exists inside `src/dependency_cache_visualizer/visualizer/` and contains `index.html` and `assets/`.
    *   Check backend logs for warnings about the frontend build directory not being found.
    *   Run `npm run build` in the `frontend/` directory to generate the assets if they are missing.
*   **API Calls Failing (Network Error, CORS Error):**
    *   **During Frontend Development (`npm run dev`):** Ensure the Python backend server is running and accessible at the address specified in the `target` of the `server.proxy` configuration in `frontend/vite.config.js`. Check the browser's developer console (Network tab) for failed requests.
    *   **When Running Packaged Version:** CORS should be handled by the FastAPI backend (`CORSMiddleware`). If issues persist, check browser console and backend logs. Ensure the API prefix `/api` is used correctly in frontend calls.
*   **Auto-Refresh Not Working:**
    *   Ensure an interval (e.g., "5s") is selected in the UI dropdown.
    *   Check the browser's developer console (Network tab) to see if requests to `/api/tree` and `/api/stats` are being sent periodically and succeeding (Status 200 OK). Look for errors in the Console tab.
    *   Auto-refresh might pause if an error occurs during data fetching. Check the UI for error messages.
*   **Data Preview Shows `[object Object]` or Limited Info:**
    *   The current preview uses `JSON.stringify`. This works well for simple JSON-compatible data but not for complex Python objects (like DataFrames, custom classes) unless they have a suitable `toJSON` method or are handled specifically. Future enhancements aim to improve this.
*   **Operations Fail:**
    *   Ensure the path format in the input field is correct (slash-separated).
    *   If adding data, ensure the data input is valid JSON or a simple string. Check browser console and backend logs for specific error messages from the API.

---